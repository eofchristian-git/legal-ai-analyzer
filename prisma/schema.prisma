generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Document {
  id            String   @id @default(cuid())
  filename      String
  fileType      String
  filePath      String
  extractedText String
  fileSize      Int
  pageCount     Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  contracts        Contract[]
  ndaTriages       NdaTriage[]
  complianceChecks ComplianceCheck[]
  riskAssessments  RiskAssessment[]
  clientContracts  ClientContract[]
}

model Contract {
  id            String    @id @default(cuid())
  documentId    String
  document      Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  title         String
  contractType  String?
  ourSide       String
  counterparty  String?
  deadline      DateTime?
  focusAreas    String?
  dealContext   String?
  status        String    @default("pending")
  createdBy     String?
  createdByUser User?     @relation("ContractsCreated", fields: [createdBy], references: [id])
  clientId      String?
  client        Client?   @relation(fields: [clientId], references: [id], onDelete: SetNull)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  analysis         ContractAnalysis?
  activityLogs     ActivityLog[]
  contractDocument ContractDocument?  // NEW: Document viewer data (Feature 008)
}

// NEW: ContractDocument model for document viewer (Feature 008)
model ContractDocument {
  id                String   @id @default(cuid())
  contractId        String   @unique
  contract          Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  
  // Original document
  originalPdfPath   String
  
  // Converted content
  htmlContent       String?  // Nullable until conversion completes
  pageCount         Int
  
  // Position mappings (stored as JSON)
  clausePositions   String   @default("[]")  // JSON array of ClausePosition
  findingPositions  String   @default("[]")  // JSON array of FindingPosition
  
  // Conversion status
  conversionStatus  String   @default("pending")  // 'pending' | 'processing' | 'completed' | 'failed'
  conversionError   String?
  
  // Timestamps
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@index([contractId])
  @@index([conversionStatus])
  @@index([createdAt])
}

model ContractAnalysis {
  id                  String            @id @default(cuid())
  contractId          String            @unique
  contract            Contract          @relation(fields: [contractId], references: [id], onDelete: Cascade)
  overallRisk         String
  greenCount          Int               @default(0)
  yellowCount         Int               @default(0)
  redCount            Int               @default(0)
  rawAnalysis         String
  clauseAnalyses      String
  redlineSuggestions  String
  negotiationStrategy String?
  executiveSummary    String?
  modelUsed           String
  tokensUsed          Int?
  reviewBasis         String
  playbookVersionId   String?
  playbookSnapshotId  String?
  playbookSnapshot    PlaybookSnapshot? @relation(fields: [playbookSnapshotId], references: [id])
  finalized           Boolean           @default(false)
  finalizedAt         DateTime?
  finalizedBy         String?
  finalizedByUser     User?             @relation("AnalysesFinalizedBy", fields: [finalizedBy], references: [id])
  createdBy           String?
  createdByUser       User?             @relation("AnalysesCreated", fields: [createdBy], references: [id])
  createdAt           DateTime          @default(now())
  
  // NEW: Deviation-focused analysis fields (Feature 005)
  formatVersion       Int               @default(1)  // 1 = old clause-based, 2 = new deviation-based
  totalClauses        Int               @default(0)  // Total clauses in document (v2 only)

  clauses           AnalysisClause[]
  negotiationItems  NegotiationItem[]
}

model NdaTriage {
  id               String   @id @default(cuid())
  documentId       String
  document         Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  title            String
  context          String?
  status           String   @default("pending")
  classification   String?
  ndaType          String?
  term             String?
  governingLaw     String?
  rawAnalysis      String?
  screeningResults String?
  issuesFound      String?
  recommendation   String?
  modelUsed        String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model ComplianceCheck {
  id            String   @id @default(cuid())
  documentId    String
  document      Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  title         String
  regulations   String
  analysisType  String
  status        String   @default("pending")
  rawAnalysis   String?
  findings      String?
  overallStatus String?
  modelUsed     String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model RiskAssessment {
  id                String   @id @default(cuid())
  documentId        String
  document          Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  title             String
  category          String
  context           String?
  status            String   @default("pending")
  severity          Int?
  likelihood        Int?
  riskScore         Int?
  riskLevel         String?
  rawAnalysis       String?
  riskMemo          String?
  mitigationOptions String?
  modelUsed         String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model Playbook {
  id        String   @id @default(cuid())
  version   Int      @default(0)
  updatedBy String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  rules     PlaybookRule[]
  snapshots PlaybookSnapshot[]
}

model PlaybookGroup {
  id          String         @id @default(cuid())
  name        String         @unique
  slug        String         @unique
  sortOrder   Int            @default(0)
  description String?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  rules       PlaybookRule[]
}

model PlaybookRule {
  id                  String         @id @default(cuid())
  playbookId          String
  playbook            Playbook       @relation(fields: [playbookId], references: [id], onDelete: Cascade)
  groupId             String?
  group               PlaybookGroup? @relation(fields: [groupId], references: [id])
  title               String
  description         String
  country             String?
  riskLevel           String
  standardPosition    String?
  acceptableRange     String?
  escalationTrigger   String?
  negotiationGuidance String?
  deleted             Boolean        @default(false)
  createdBy           String
  updatedBy           String
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
}

model PlaybookSnapshot {
  id         String   @id @default(cuid())
  playbookId String
  playbook   Playbook @relation(fields: [playbookId], references: [id], onDelete: Cascade)
  version    Int
  createdBy  String
  createdAt  DateTime @default(now())

  rules    PlaybookSnapshotRule[]
  analyses ContractAnalysis[]
}

model PlaybookSnapshotRule {
  id                  String           @id @default(cuid())
  snapshotId          String
  snapshot            PlaybookSnapshot @relation(fields: [snapshotId], references: [id], onDelete: Cascade)
  groupId             String?
  groupName           String?
  title               String
  description         String
  country             String?
  riskLevel           String
  standardPosition    String?
  acceptableRange     String?
  escalationTrigger   String?
  negotiationGuidance String?
  originalRuleId      String
  createdBy           String
  originalCreatedAt   DateTime
  createdAt           DateTime         @default(now())
}

model AnalysisClause {
  id           String           @id @default(cuid())
  analysisId   String
  analysis     ContractAnalysis @relation(fields: [analysisId], references: [id], onDelete: Cascade)
  clauseNumber String           @default("")
  clauseName          String
  clauseText          String?    // Made optional for formatVersion=2 (Feature 005)
  clauseTextFormatted String?
  position            Int
  createdAt    DateTime         @default(now())
  
  // NEW: Clause Decision Actions fields (Feature 006)
  updatedAt    DateTime         @default(now()) @updatedAt  // For optimistic locking / conflict detection
  originalText String?                                       // Original text for projection baseline

  findings AnalysisFinding[]
  decisions ClauseDecision[]  // NEW: Decision history (Feature 006)

  @@unique([analysisId, position])
  @@index([id, updatedAt])  // NEW: For efficient conflict detection (Feature 006)
}

// NEW: Role-Permission mapping for RBAC (Feature 006)
// Note: SQLite doesn't support enums, so we use String with validation in app code
// Valid roles: "admin" | "legal" | "compliance"
// Valid permissions: "REVIEW_CONTRACTS" | "APPROVE_ESCALATIONS" | "MANAGE_USERS" | "MANAGE_PLAYBOOK"
model RolePermission {
  id         String   @id @default(cuid())
  role       String                           // "admin" | "legal" | "compliance"
  permission String                           // "REVIEW_CONTRACTS" | "APPROVE_ESCALATIONS" | "MANAGE_USERS" | "MANAGE_PLAYBOOK"
  createdAt  DateTime @default(now())

  @@unique([role, permission])  // One permission per role (no duplicates)
  @@index([role])               // Fast lookup by role
}

// NEW: Clause Decision model for append-only history (Feature 006)
// Note: SQLite doesn't support enums, so actionType is String with validation in app code
// Valid actionTypes: "ACCEPT_DEVIATION" | "APPLY_FALLBACK" | "EDIT_MANUAL" | "ESCALATE" | "ADD_NOTE" | "UNDO" | "REVERT"
model ClauseDecision {
  id         String           @id @default(cuid())
  clauseId   String
  clause     AnalysisClause   @relation(fields: [clauseId], references: [id], onDelete: Cascade)
  findingId  String?          // Required for new decisions; null only for legacy clause-level records (Feature 006)
  finding    AnalysisFinding? @relation(fields: [findingId], references: [id], onDelete: SetNull)
  userId     String
  user       User             @relation("ClauseDecisions", fields: [userId], references: [id])
  actionType String                              // "ACCEPT_DEVIATION" | "APPLY_FALLBACK" | "EDIT_MANUAL" | "ESCALATE" | "ADD_NOTE" | "UNDO" | "REVERT"
  timestamp  DateTime         @default(now())
  payload    String                              // JSON string with action-specific data

  @@index([clauseId, timestamp])              // For chronological replay in projection
  @@index([clauseId, findingId, timestamp])   // For finding-level projection queries
  @@index([clauseId])                         // For cache invalidation queries
}

model AnalysisFinding {
  id               String         @id @default(cuid())
  clauseId         String
  clause           AnalysisClause @relation(fields: [clauseId], references: [id], onDelete: Cascade)
  riskLevel        String
  matchedRuleTitle String
  matchedRuleId    String?
  summary          String
  fallbackText     String
  whyTriggered     String
  excerpt          String         @default("")
  triageDecision   String?
  triageNote       String?
  triagedBy        String?
  triagedByUser    User?          @relation("FindingsTriagedBy", fields: [triagedBy], references: [id])
  triagedAt        DateTime?
  createdAt        DateTime       @default(now())
  
  // NEW: Deviation-focused analysis fields (Feature 005)
  contextBefore    String?        // Text before the excerpt for understanding
  contextAfter     String?        // Text after the excerpt for understanding
  locationPage     Int?           // Approximate page number in document
  locationPosition String?        // Approximate position: "top" | "middle" | "bottom"

  comments  FindingComment[]
  decisions ClauseDecision[]  // NEW: Reverse relation for finding-level decisions (Feature 007)
}

model FindingComment {
  id        String          @id @default(cuid())
  findingId String
  finding   AnalysisFinding @relation(fields: [findingId], references: [id], onDelete: Cascade)
  userId    String
  user      User            @relation("FindingComments", fields: [userId], references: [id])
  content   String
  createdAt DateTime        @default(now())
}

model ActivityLog {
  id         String   @id @default(cuid())
  contractId String
  contract   Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  action     String
  userId     String
  user       User     @relation("ActivityLogs", fields: [userId], references: [id])
  targetType String?
  targetId   String?
  metadata   String?
  createdAt  DateTime @default(now())
}

model NegotiationItem {
  id          String           @id @default(cuid())
  analysisId  String
  analysis    ContractAnalysis @relation(fields: [analysisId], references: [id], onDelete: Cascade)
  priority    String           // "P1" | "P2" | "P3"
  title       String
  description String
  clauseRef   String?
  position    Int
  createdAt   DateTime         @default(now())
}

model Client {
  id              String    @id @default(cuid())
  name            String
  country         String
  industry        String?
  contactPerson   String?
  contactEmail    String?
  contactPhone    String?
  notes           String?
  deleted         Boolean   @default(false)
  deletedAt       DateTime?
  createdBy       String?
  createdByUser   User?     @relation("ClientsCreated", fields: [createdBy], references: [id])
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  contracts       ClientContract[]
  reviewContracts Contract[]
}

model ClientContract {
  id          String   @id @default(cuid())
  clientId    String
  client      Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  documentId  String
  document    Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  title       String?
  uploadedBy  String?
  uploadedByUser User? @relation("ClientContractsUploaded", fields: [uploadedBy], references: [id])
  createdAt   DateTime @default(now())

  @@unique([clientId, documentId])
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  password  String
  role      String   @default("legal")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  contractsCreated           Contract[]         @relation("ContractsCreated")
  analysesCreated            ContractAnalysis[]  @relation("AnalysesCreated")
  analysesFinalizedBy        ContractAnalysis[]  @relation("AnalysesFinalizedBy")
  findingsTriagedBy          AnalysisFinding[]   @relation("FindingsTriagedBy")
  findingComments            FindingComment[]    @relation("FindingComments")
  activityLogs               ActivityLog[]       @relation("ActivityLogs")
  clientsCreated             Client[]            @relation("ClientsCreated")
  clientContractsUploaded    ClientContract[]    @relation("ClientContractsUploaded")
  decisions                  ClauseDecision[]    @relation("ClauseDecisions")  // NEW: Decision history (Feature 006)
}
